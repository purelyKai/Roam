-- ============================================
-- ROAM DATABASE SCHEMA
-- Run this in Supabase SQL Editor
-- ============================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS earthdistance CASCADE;

-- --------------------------------------------
-- 1. HOTSPOTS (WiFi hotspot locations)
-- --------------------------------------------
-- Drop old table if exists (fresh development)
DROP TABLE IF EXISTS wifi_sessions CASCADE;
DROP TABLE IF EXISTS transactions CASCADE;
DROP TABLE IF EXISTS hotspots CASCADE;

CREATE TABLE hotspots (
    id BIGSERIAL PRIMARY KEY,
    
    -- Device ID: provided by edge device (UUID generated on Pi)
    device_id VARCHAR(36) UNIQUE NOT NULL,
    
    -- Display
    name VARCHAR(255) NOT NULL,
    icon_url TEXT,
    
    -- Location
    latitude DECIMAL(10, 7) NOT NULL,
    longitude DECIMAL(10, 7) NOT NULL,
    
    -- WiFi Credentials
    ssid VARCHAR(255) NOT NULL,
    password VARCHAR(255),
    
    -- Pricing (cents per minute, e.g., 2 = $0.02/min = $1.20/hour)
    price_per_minute_cents INTEGER NOT NULL DEFAULT 2,
    
    -- Stripe Connect (for business payouts)
    stripe_account_id VARCHAR(255),
    
    -- Status
    is_active BOOLEAN DEFAULT TRUE,
    is_online BOOLEAN DEFAULT FALSE,
    last_heartbeat_at TIMESTAMPTZ,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_hotspots_device_id ON hotspots(device_id);
CREATE INDEX idx_hotspots_location ON hotspots USING gist (ll_to_earth(latitude, longitude));
CREATE INDEX idx_hotspots_active ON hotspots(is_active) WHERE is_active = TRUE;

-- --------------------------------------------
-- 2. TRANSACTIONS (Payment records)
-- --------------------------------------------
CREATE TABLE transactions (
    id BIGSERIAL PRIMARY KEY,
    
    -- Stripe
    payment_intent_id VARCHAR(255) UNIQUE NOT NULL,
    
    -- Relations
    hotspot_id BIGINT REFERENCES hotspots(id) NOT NULL,
    
    -- Money (all in cents to avoid float precision issues)
    amount_cents INTEGER NOT NULL,
    platform_fee_cents INTEGER NOT NULL,
    business_payout_cents INTEGER NOT NULL,
    
    -- Purchase details
    duration_minutes INTEGER NOT NULL,
    
    -- Status: pending, succeeded, failed, refunded
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    
    -- Customer info (for support, not authentication)
    customer_device_id VARCHAR(36),
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    
    -- Constraints
    CONSTRAINT transactions_positive_amount CHECK (amount_cents > 0),
    CONSTRAINT transactions_positive_fee CHECK (platform_fee_cents >= 0),
    CONSTRAINT transactions_positive_payout CHECK (business_payout_cents >= 0)
);

-- Indexes
CREATE INDEX idx_transactions_hotspot ON transactions(hotspot_id);
CREATE INDEX idx_transactions_status ON transactions(status);
CREATE INDEX idx_transactions_created ON transactions(created_at DESC);

-- --------------------------------------------
-- 3. WIFI_SESSIONS (Session history for analytics)
-- --------------------------------------------
-- Note: Active sessions are also stored in Redis for fast lookups
-- This table keeps history for analytics and audit trails
CREATE TABLE wifi_sessions (
    id BIGSERIAL PRIMARY KEY,
    
    -- Relations
    transaction_id BIGINT REFERENCES transactions(id),
    hotspot_id BIGINT REFERENCES hotspots(id) NOT NULL,
    
    -- Session token (generated by backend)
    session_token VARCHAR(36) UNIQUE NOT NULL,
    
    -- Timing (milliseconds since Unix epoch for consistency with mobile app)
    duration_minutes INTEGER NOT NULL,
    started_at BIGINT NOT NULL,
    expires_at BIGINT NOT NULL,
    
    -- Customer
    customer_device_id VARCHAR(36) NOT NULL,
    client_ip INET,
    
    -- Status: active, expired, revoked
    status VARCHAR(50) NOT NULL DEFAULT 'active',
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_sessions_token ON wifi_sessions(session_token);
CREATE INDEX idx_sessions_hotspot ON wifi_sessions(hotspot_id);
CREATE INDEX idx_sessions_status ON wifi_sessions(status);
CREATE INDEX idx_sessions_expires ON wifi_sessions(expires_at);

-- --------------------------------------------
-- 4. AUTO-UPDATE TIMESTAMP TRIGGER
-- --------------------------------------------
CREATE OR REPLACE FUNCTION trigger_set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_hotspots_updated_at
    BEFORE UPDATE ON hotspots
    FOR EACH ROW EXECUTE FUNCTION trigger_set_updated_at();

-- --------------------------------------------
-- 5. HELPER VIEWS (Optional - for analytics)
-- --------------------------------------------
-- Note: Views use SECURITY INVOKER to respect RLS policies.
-- Only service_role can access underlying tables.

-- View: Daily revenue summary (admin only)
CREATE OR REPLACE VIEW daily_revenue 
WITH (security_invoker = on) AS
SELECT 
    DATE(created_at) as date,
    hotspot_id,
    COUNT(*) as transaction_count,
    SUM(amount_cents) as total_revenue_cents,
    SUM(platform_fee_cents) as platform_revenue_cents,
    SUM(business_payout_cents) as business_payout_cents,
    SUM(duration_minutes) as total_minutes_sold
FROM transactions
WHERE status = 'succeeded'
GROUP BY DATE(created_at), hotspot_id
ORDER BY date DESC;

-- View: Active sessions count per hotspot (admin only)
CREATE OR REPLACE VIEW active_sessions_count 
WITH (security_invoker = on) AS
SELECT 
    h.id as hotspot_id,
    h.name as hotspot_name,
    COUNT(s.id) as active_session_count
FROM hotspots h
LEFT JOIN wifi_sessions s ON h.id = s.hotspot_id AND s.status = 'active'
GROUP BY h.id, h.name;

-- Revoke public access to analytics views (sensitive data)
REVOKE ALL ON daily_revenue FROM anon, authenticated;
REVOKE ALL ON active_sessions_count FROM anon, authenticated;

-- Only service_role can access views
GRANT SELECT ON daily_revenue TO service_role;
GRANT SELECT ON active_sessions_count TO service_role;

-- --------------------------------------------
-- 6. ROW LEVEL SECURITY (RLS)
-- --------------------------------------------
-- Note: Since Spring Boot connects as a service role (trusted backend),
-- RLS provides defense-in-depth. Service role bypasses RLS by default.
-- These policies only apply if using Supabase client directly.

-- Enable RLS on all tables
ALTER TABLE hotspots ENABLE ROW LEVEL SECURITY;
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE wifi_sessions ENABLE ROW LEVEL SECURITY;

-- HOTSPOTS: Public read for active hotspots, service role for writes
CREATE POLICY "Hotspots: Public read active"
    ON hotspots FOR SELECT
    USING (is_active = TRUE);

CREATE POLICY "Hotspots: Service role full access"
    ON hotspots FOR ALL
    USING (auth.role() = 'service_role');

-- TRANSACTIONS: Only service role can access (sensitive financial data)
CREATE POLICY "Transactions: Service role only"
    ON transactions FOR ALL
    USING (auth.role() = 'service_role');

-- WIFI_SESSIONS: Only service role can access
CREATE POLICY "Sessions: Service role only"
    ON wifi_sessions FOR ALL
    USING (auth.role() = 'service_role');

-- Grant service role full access (already default, but explicit)
GRANT ALL ON hotspots TO service_role;
GRANT ALL ON transactions TO service_role;
GRANT ALL ON wifi_sessions TO service_role;

-- Grant public/anon read on hotspots only
GRANT SELECT ON hotspots TO anon;
GRANT SELECT ON hotspots TO authenticated;
